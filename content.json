{"meta":{"title":"MAXRISK","subtitle":"Quick notes","description":"stay hungry, stay foolish","author":"Jesse Chan","url":"http://yoursite.com"},"pages":[{"title":"标签","date":"2016-10-24T08:11:28.000Z","updated":"2016-12-01T09:10:40.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PHP_XLSXWriter 代替 PHPExcel","slug":"xlsxwriter","date":"2017-04-18T05:57:35.000Z","updated":"2017-04-18T06:48:05.000Z","comments":true,"path":"2017/04/18/xlsxwriter/","link":"","permalink":"http://yoursite.com/2017/04/18/xlsxwriter/","excerpt":"在我上一篇博客中，解决了 PHPExcel 内存溢出的问题。但是，查询一万条数据时，PHP 执行超时了。经过谷歌发现，这是 PHPExcel 本身效率的问题，随后发现有个叫 PHP_XLSXWriter 的插件可以代替 PHPExcel。 无法打开文件刚开始用的时候，用官方给的示例代码，导出的文件为0字节，且文件无法打开，但是用命令行运行示例代码却可以正常导出。","text":"在我上一篇博客中，解决了 PHPExcel 内存溢出的问题。但是，查询一万条数据时，PHP 执行超时了。经过谷歌发现，这是 PHPExcel 本身效率的问题，随后发现有个叫 PHP_XLSXWriter 的插件可以代替 PHPExcel。 无法打开文件刚开始用的时候，用官方给的示例代码，导出的文件为0字节，且文件无法打开，但是用命令行运行示例代码却可以正常导出。我开始跟踪代码，发现有个地方用到了系统的缓存目录，PHP 程序自然不能在系统目录在进行读写。通过 XLSXWriter::setTempDir() 这个方法设置缓存目录到当前的工程中，问题就解决了。 总结虽然 PHP_XLSXWriter 的功能没有 PHPExcel 强大，但是已经足够用了，最重要的是效率大大的提高了。一万条数据的导出 PHPExcel 要50秒以上，而 PHP_XLSXWriter 不到10秒就可以搞定了。这个提升可以说是质的飞越，再也不用超时的问题，也不用当心内存溢出。 PHP_XLSXWriter 只有一个文件，里面有两个类，很轻量，官方的示例代码也足够详细，容易上手，嫌 PHPExcel 慢的读者可以试试这个插件。","categories":[],"tags":[{"name":"php","slug":"php","permalink":"http://yoursite.com/tags/php/"}],"keywords":[]},{"title":"PHPExcel 内存溢出解决方法与生成器","slug":"20170303","date":"2017-03-03T08:35:20.000Z","updated":"2017-03-09T08:26:12.000Z","comments":true,"path":"2017/03/03/20170303/","link":"","permalink":"http://yoursite.com/2017/03/03/20170303/","excerpt":"最近我们公司做了一个对账平台，我负责做报表这一块。我发现用 PHPExcel 导出5000条以上的数据就出现了这个问题（php.ini 的默认的内存限制是 128M） 1Allowed memory size of 134217728 bytes exhausted (tried to allocate 54 bytes) 最先想到的是修改 php.ini 的内存限制，但这个方法制标不制本，只能寻找别的解决方法。 下面简单阐述一下我的解决过程123456// 获取数据public function getDetail($map) &#123; echo memory_get_usage(), '&lt;br&gt;'; $data = M('table')-&gt;field('field1,field2,field3,...')-&gt;where($map)-&gt;order('order_time DESC')-&gt;limit(5000)-&gt;select(); return $data;&#125;","text":"最近我们公司做了一个对账平台，我负责做报表这一块。我发现用 PHPExcel 导出5000条以上的数据就出现了这个问题（php.ini 的默认的内存限制是 128M） 1Allowed memory size of 134217728 bytes exhausted (tried to allocate 54 bytes) 最先想到的是修改 php.ini 的内存限制，但这个方法制标不制本，只能寻找别的解决方法。 下面简单阐述一下我的解决过程123456// 获取数据public function getDetail($map) &#123; echo memory_get_usage(), '&lt;br&gt;'; $data = M('table')-&gt;field('field1,field2,field3,...')-&gt;where($map)-&gt;order('order_time DESC')-&gt;limit(5000)-&gt;select(); return $data;&#125; 1234567891011121314151617181920public function __construct() &#123; $this-&gt;objPHPExcel = new \\PHPExcel();&#125;// 遍历 Excel 数据protected function setSheetData($data) &#123; echo memory_get_usage(), '&lt;br&gt;'; $activeSheet = $this-&gt;objPHPExcel-&gt;getActiveSheet(); //导入数据 foreach ($data as $key =&gt; $value) &#123; $index = $key + 2; $activeSheet-&gt;setCellValueExplicit('A'.$index, $value['field1'], \\PHPExcel_Cell_DataType::TYPE_STRING); $activeSheet-&gt;setCellValueExplicit('B'.$index, $value['field2'], \\PHPExcel_Cell_DataType::TYPE_STRING); $activeSheet-&gt;setCellValue('C'.$index, $value['field3']); ... &#125; echo 'foreach: ' . memory_get_usage(), '&lt;br&gt;'; exit;&#125; 以下测试数据都是基于导出 5000 条数据产生的 过程 查询数据前 查询数据后 遍历数据 优化前 6M 26M 70M 通过 php 函数 memory_get_usage 可以获取到如上数据。可以发现，内存占用大的情况出现在查询后和遍历 Excel 数据的时候。 PHPExcel 大数据量情况下内存溢出解决PHPExcel 可以通过缓存来解决这种情况，大家可以参考这篇 文章 来解决遍历数据那一步 123456public function __construct() &#123; $cacheMethod = \\PHPExcel_CachedObjectStorageFactory::cache_in_memory_gzip; $cacheSettings = array('cache_in_memory_gzip'=&gt;'30MB'); \\PHPExcel_Settings::setCacheStorageMethod($cacheMethod, $cacheSettings); $this-&gt;objPHPExcel = new \\PHPExcel();&#125; 过程 查询数据前 查询数据后 遍历数据 优化后 6M 26M 51M 注销遍历完的变量在上面的代码中，$data 是存了 5000 条数据的变量，占用了较大的内存。我们遍历完数据后这个变量也就没用了，所以我们可以用 unset() 来的注销这个变量。但是重点在下文的生成器，就算不用 unset() 也没关系了。 过程 查询数据前 查询数据后 遍历数据 注销变量 优化后 6M 26M 51M 35M 应用 PHP 的生成器 官方注释：生成器提供了一种更容易的方法来实现简单的对象迭代，相比较定义类实现 Iterator 接口的方式，性能开销和复杂性大大降低。 我最近在学习 python，看到了生成器这部分，想起了 PHP 也有生成器。我们不可能把成千上万条数据存到变量中，这样内存一下子就达到上限了。但我们可以利用生成器，代码如下： 12345678public function getDetail($map) &#123; $sql = \"SELECT `field1`,`field2`,`field3` ... FROM `table` LIMIT 5000\"; $conn = mysqli_connect('127.0.0.1', 'root', '', 'database'); $res = mysqli_query($conn, $sql); while ($row = mysqli_fetch_assoc($res)) &#123; yield $row; &#125;&#125; 过程 查询数据前 查询数据后 遍历数据 最初 6M 26M 70M 最终 6M 6M 31M 经过测试，查询数据前后的内存占用基本不变。经过上面几步的优化，遍历数据那一步现在的内存占用也只有 31M 了。就算是 php.ini 默认的 128M 的内存也足够用了。关于生成器的详细介绍，大家可以去看 PHP 官方手册。我发现网上在解决这个问题没有用上生成器，所以便有了这篇文章。解决了这类问题还是满有成就感的，嘿嘿!","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}],"keywords":[]},{"title":"Mac 系统中使用 crontab 的问题","slug":"mac-crontab","date":"2017-01-19T02:15:22.000Z","updated":"2017-01-19T03:01:12.000Z","comments":true,"path":"2017/01/19/mac-crontab/","link":"","permalink":"http://yoursite.com/2017/01/19/mac-crontab/","excerpt":"我试图通过运行 crontab -e 命令在 Unix 系统上设置定时任务。但是当我保存退出时，我得到以下错误： crontab: no crontab for maxrisk – using an empty one crontab: “/usr/bin/vi” exited with status 1 在 Linux 系统或类 Unix 系统如何解决这个问题呢？","text":"我试图通过运行 crontab -e 命令在 Unix 系统上设置定时任务。但是当我保存退出时，我得到以下错误： crontab: no crontab for maxrisk – using an empty one crontab: “/usr/bin/vi” exited with status 1 在 Linux 系统或类 Unix 系统如何解决这个问题呢？ 你需要正确设置一个叫 EDITOR 的环境变量。我们可以通过设置 VISUAL 或 EDITOR环境变量来指定编辑当前 crontab 的编辑器。 输入： $ crontab -e 在没有设置的这个两个环境变量的情况下，你就会得到以下错误 指定使用 vim 编辑器来修复这个错误1export EDITOR=vim 或者你使用的是 emacs1export EDITOR=emacs 或是 nano1export EDITOR=nano 现在你就可以正常使用 mac 的定时任务了。","categories":[],"tags":[{"name":"mac","slug":"mac","permalink":"http://yoursite.com/tags/mac/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}],"keywords":[]},{"title":"Linux笔记","slug":"Linux-note","date":"2016-12-21T13:10:05.000Z","updated":"2016-12-28T07:22:01.000Z","comments":true,"path":"2016/12/21/Linux-note/","link":"","permalink":"http://yoursite.com/2016/12/21/Linux-note/","excerpt":"linux界面1[root@localhost ~] # root 为当前用户 localhost 为当前主机名 ~ 为当前所在目录 #和$：root用户为#，普通用户为$ 常用目录的作用 / 根目录 /bin 命令保存目录（普通用户就可以读取的命令） /boot 启动目录，启动相关文件 /dev 设备文件保存目录 /etc 配置文件保存目录 /home 普通用户的家目录 /lib 系统库保存目录 /mnt 系统挂载目录 /media 挂载目录 /root 超级用户的家目录 /tmp 临时目录 /sbin 命令保存目录 /proc 直接写入内存的 /sys /usr 系统软件资源目录 /usr/bin/ 系统命令（普通用户） /usr/sbin/ 系统命令（超级用户） /var 系统相关文档的内容","text":"linux界面1[root@localhost ~] # root 为当前用户 localhost 为当前主机名 ~ 为当前所在目录 #和$：root用户为#，普通用户为$ 常用目录的作用 / 根目录 /bin 命令保存目录（普通用户就可以读取的命令） /boot 启动目录，启动相关文件 /dev 设备文件保存目录 /etc 配置文件保存目录 /home 普通用户的家目录 /lib 系统库保存目录 /mnt 系统挂载目录 /media 挂载目录 /root 超级用户的家目录 /tmp 临时目录 /sbin 命令保存目录 /proc 直接写入内存的 /sys /usr 系统软件资源目录 /usr/bin/ 系统命令（普通用户） /usr/sbin/ 系统命令（超级用户） /var 系统相关文档的内容 常用命令mkdir mkdir [-p]：创建目录 [递归创建] cp -r 复制目录 -p 连带文件属性复制 -d 若源文件是链接文件，则复制链接属性 -a 相当于 -pdr mv [原文件或目录] [目标目录] 剪切或改名命令 ln 硬链接特征 拥有相同的i节点和存储block块，可以看做是一个文件 可以通过i节点识别 不能跨分区 不能针对目录使用 ln -s 软链接特征 类似Windows快捷方式 软链接有自己的i节点和block块，但是数据块中只保存原文件的文件名和i节点号，并没有实际的文件数据 lrwxrwxrwx l代表软链接（软链接的文件权限都为rwxrwxrwx） 修改任意文件，另一个都改变 删除原文件，软链接不能使用 搜索文件命令 在后台数据库中按文件名搜索，搜索速度更快 1locate 文件名 /var/lib/mlocate 为locate命令搜索的后台数据库 updatedb 更新数据库命令 find123456789101112131415161718find /root -inname install.log#不区分大小写find /root -user root# 按照所有者搜索find /root -nouser# 查找没有所有者的文件find /var/log/ -mtime +10# 查找10天前修改的文件# -10 10天内修改的文件# 10 10天当天修改的文件# +10 10天前修改的文件# atime 文件访问时间# ctime 改变文件属性# mtime 修改文件内容 grep1234grep [选项] 字符串 文件名# 在文件当是匹配符合条件的字条串-i 忽略大小写-v 排除指定字符串 man123man -k # 相当于 apropos 命令# 例如： apropos passwd shutdown [选项] 时间12345678shutdown -c# 取消上一个关机命令shutdown -h # 关机shutdown -r# 重启","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"keywords":[]},{"title":"在php5.3下踩的一个坑","slug":"shadowsocks","date":"2016-10-26T07:57:26.000Z","updated":"2016-12-28T07:22:51.000Z","comments":true,"path":"2016/10/26/shadowsocks/","link":"","permalink":"http://yoursite.com/2016/10/26/shadowsocks/","excerpt":"最近在部署一个CMS的项目中遇到了一些问题，有些页面可以访问，有些页面状态码则报：500 internal server error。由于在自己电脑上跑的PHP版本是5.6的，并不会报这个错。因为服务器上关闭了调试模式，查了nginx的错误日志，才发现这个报错。 empty()仅支持变量 在PHP的官方手册上有提示：在 PHP 5.5 之前，empty() 仅支持变量；任何其他东西将会导致一个解析错误。换言之，下列代码不会生效： empty(trim($name))。 作为替代，应该使用trim($name) == false.","text":"最近在部署一个CMS的项目中遇到了一些问题，有些页面可以访问，有些页面状态码则报：500 internal server error。由于在自己电脑上跑的PHP版本是5.6的，并不会报这个错。因为服务器上关闭了调试模式，查了nginx的错误日志，才发现这个报错。 empty()仅支持变量 在PHP的官方手册上有提示：在 PHP 5.5 之前，empty() 仅支持变量；任何其他东西将会导致一个解析错误。换言之，下列代码不会生效： empty(trim($name))。 作为替代，应该使用trim($name) == false. 如果没没有使用变量，PHP则会报一个致使错误 PHP message: PHP Fatal error: Can’t use function return value in write context in … 在ThinkPHP中，判断I(‘post.’)或I(‘get.’)是否为空，先赋值再判断或如下1I('get.param') == false ? '' : 'TODO'; 以后在开发的时候还是尽量把开发环境和生产环境统一一下比较好，这样就避免了说“我机器上好好的……”，在部署时也少很多麻烦。","categories":[],"tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://yoursite.com/tags/ThinkPHP/"}],"keywords":[]}]}